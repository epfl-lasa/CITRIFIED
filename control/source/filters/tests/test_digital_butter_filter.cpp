#include "filters/DigitalButterworth.h"

#include <stdexcept>
#include <gtest/gtest.h>

using namespace filter;

class DigitalButterworthTest : public testing::Test {
protected:
  void SetUp() override {
    path = std::string(FILTER_TEST_FIXTURES) + "filter_config.yaml";
    setTestConfigurations();
  }

  std::string path;

  double tol = 1e-5;

  // Known test trajectory generated by fixtures/generateFilterTest.m for filter with name 'filer_test'
  std::vector<double> testInput;
  std::vector<double> testOutput;

  void setTestConfigurations() {
    // Test trajectory 1:
    testInput = {1, 3, 6, 5, 3, 7, 8, 9, 13, 10, 8, 7, 5, 7, 8, 10};

    // Expected results for trajectory 1:
    testOutput = {
        1.54814840530593e-07, 1.68670456607597e-06, 9.40427513752302e-06, 3.54991174273726e-05, 0.000101994978895171,
        0.000240266613957550, 0.000490553250561740, 0.000903945250091598, 0.00154534676599801, 0.00249590613306554,
        0.00385324878841180, 0.00572771517302957, 0.00823641237168783, 0.0114982682531717, 0.0156317160330637,
        0.0207553779753722
    };
  }
};

TEST_F(DigitalButterworthTest, TestWrongNumCoeff) {
  EXPECT_THROW(filter::DigitalButterworth filter("filter_fail_test", path), std::invalid_argument);
}

TEST_F(DigitalButterworthTest, TestFilter) {
  filter::DigitalButterworth filter("filter_test", path);
  for (std::size_t i = 0; i < testInput.size(); ++i) {
    EXPECT_NEAR(filter.computeFilterOutput(testInput.at(i)), testOutput.at(i), tol);
  }
}

TEST_F(DigitalButterworthTest, TestFilterReset) {
  filter::DigitalButterworth filter("filter_test", path);
  for (std::size_t i = 0; i < testInput.size(); ++i) {
    filter.computeFilterOutput(testInput.at(i));
  }
  EXPECT_GT(abs(filter.computeFilterOutput(0)), 0);

  filter.resetFilter();
  EXPECT_EQ(filter.computeFilterOutput(0), 0);
}