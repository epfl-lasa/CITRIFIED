#include "filters/DigitalButterworth.h"

#include <stdexcept>
#include <gtest/gtest.h>

using namespace filter;

class DigitalButterworthTest : public testing::Test {
protected:
  void SetUp() override {
    path = std::string(FILTER_TEST_FIXTURES) + "filter_config.yaml";
    setTestConfigurations();
  }

  std::string path;

  double tol = 1e-5;

  // Known test trajectory generated by fixtures/generateFilterTest.m for filter with name 'filer_test'
  std::vector<double> testInput1D;
  std::vector<double> testOutput1D;

  void setTestConfigurations() {
    // Test trajectory 1:
    testInput1D = {1, 3, 6, 5, 3, 7, 8, 9, 13, 10, 8, 7, 5, 7, 8, 10};

    // Expected results for trajectory 1:
    testOutput1D = {
        1.54814840530593e-07, 1.68670456607597e-06, 9.40427513752302e-06, 3.54991174273726e-05, 0.000101994978895171,
        0.000240266613957550, 0.000490553250561740, 0.000903945250091598, 0.00154534676599801, 0.00249590613306554,
        0.00385324878841180, 0.00572771517302957, 0.00823641237168783, 0.0114982682531717, 0.0156317160330637,
        0.0207553779753722
    };
  }
};

TEST_F(DigitalButterworthTest, TestWrongNumCoeff) {
  EXPECT_THROW(filter::DigitalButterworth filter("filter_fail_test", path, 1), std::invalid_argument);
}

TEST_F(DigitalButterworthTest, TestFilter1D) {
  filter::DigitalButterworth filter("filter_test", path, 1);
  EXPECT_THROW(filter.computeFilterOutput(Eigen::Vector2d(1, 1)), std::invalid_argument);
  for (std::size_t i = 0; i < testInput1D.size(); ++i) {
    EXPECT_NEAR(filter.computeFilterOutput(testInput1D.at(i)), testOutput1D.at(i), tol);
  }
}

TEST_F(DigitalButterworthTest, TestFilter1DReset) {
  filter::DigitalButterworth filter("filter_test", path, 1);
  for (std::size_t i = 0; i < testInput1D.size(); ++i) {
    filter.computeFilterOutput(testInput1D.at(i));
  }
  EXPECT_GT(abs(filter.computeFilterOutput(0)), 0);

  filter.resetFilter();
  EXPECT_EQ(filter.computeFilterOutput(0), 0);
}

TEST_F(DigitalButterworthTest, TestFilter2D) {
  filter::DigitalButterworth filter("filter_test", path, 2);
  EXPECT_THROW(filter.computeFilterOutput(1), std::invalid_argument);
  for (std::size_t i = 0; i < testInput1D.size(); ++i) {
    Eigen::Vector2d output = filter.computeFilterOutput(Eigen::Vector2d(testInput1D.at(i), testInput1D.at(i)));
    for (std::size_t dim = 0; dim < 2; ++dim)
      EXPECT_NEAR(output(dim), testOutput1D.at(i), tol);
  }
}